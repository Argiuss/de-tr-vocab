<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Germanâ€“Turkish Vocabulary Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0f172a" />
  <link rel="manifest" href="manifest.json" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      padding: 16px;
    }
    .edit-row td {
  background: #020617;
  padding: 10px;
}

.edit-form input,
.edit-form textarea {
  width: 100%;
  margin-top: 4px;
}
    h1, h2, h3 { margin-bottom: 8px; }
    .app-container {
      max-width: 1100px;
      margin: 0 auto;
    }
    .section {
      background: #020617;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      border: 1px solid #1e293b;
    }
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .badge {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      background: #1e293b;
      color: #e5e7eb;
    }
    label {
      font-size: 13px;
      display: block;
      margin-bottom: 4px;
      color: #9ca3af;
    }
    input[type="text"], input[type="number"], textarea {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-size: 14px;
    }
    textarea { min-height: 80px; resize: vertical; }
    input:focus, textarea:focus {
      outline: 2px solid #3b82f6;
      border-color: #3b82f6;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .btn-primary { background: #3b82f6; color: #f9fafb; }
    .btn-outline { background: transparent; color: #e5e7eb; border: 1px solid #374151; }
    .btn-danger { background: #dc2626; color: #f9fafb; }
    .btn-secondary { background: #16a34a; color: #f9fafb; }
    .btn-sm { padding: 4px 10px; font-size: 12px; }
    .btn-block { width: 100%; justify-content: center; }
    .muted { color: #9ca3af; font-size: 13px; }
    .grid { display: grid; gap: 12px; }
    @media (min-width: 768px) {
      .grid-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .grid-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    }
    .card {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 12px;
    }
    .stat-value { font-size: 20px; font-weight: 600; }
    .stat-label { font-size: 12px; color: #9ca3af; }
    .progress-bar {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: #1f2937;
      overflow: hidden;
      margin-top: 6px;
    }
    .progress-inner {
      height: 100%;
      background: #3b82f6;
      width: 0%;
      transition: width 0.3s ease;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td {
      padding: 6px 4px;
      border-bottom: 1px solid #111827;
      text-align: left;
    }
    th {
      color: #9ca3af;
      font-weight: 500;
      font-size: 12px;
      cursor: pointer;
    }
    tr:last-child td { border-bottom: none; }
    .pill {
      padding: 2px 8px;
      font-size: 11px;
      border-radius: 999px;
      display: inline-block;
    }
    .pill-low { background: #1f2937; color: #fecaca; }
    .pill-mid { background: #1e293b; color: #facc15; }
    .pill-high { background: #022c22; color: #6ee7b7; }

    .mode-toggle {
      display: inline-flex;
      border-radius: 999px;
      border: 1px solid #1f2937;
      overflow: hidden;
      background: #020617;
    }
    .mode-toggle button {
      border-radius: 0;
      background: rgba(15,23,42,0.9);
      border: none;
      padding: 6px 14px;
      font-size: 13px;
      color: #e5e7eb;
      opacity: 0.7;
    }
    .mode-active {
      background: #3b82f6 !important;
      color: #f9fafb !important;
      opacity: 1 !important;
    }

    /* Practice area + big word */
    #practice-area {
      min-height: 680px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #practice-area > * { width: 100%; }

    .practice-word {
  font-size: clamp(28px, 6vw, 52px);
  font-weight: 600;
  text-align: center;
  margin-bottom: 20px;
  line-height: 1.1;
  word-wrap: break-word;
  word-break: break-word;
}
    .practice-direction {
      text-align: center;
      font-size: 20px;
      color: #9ca3af;
      margin-bottom: 6px;
    }
    .example-sentence {
      margin-top: 16px;
      font-size: 20px;
      color: #d1d5db;
      text-align: center;
    }
    @media (max-width: 768px) {
  .practice-direction {
    font-size: 16px;
  }
  .example-sentence {
    font-size: 16px;
    padding: 0 8px;
  }
}
    .turkish-answer {
      margin-top: 16px;
      font-size: 32px;
      font-weight: 600;
      text-align: center;
      color: #fbbf24;
    }
    .german-answer {
      margin-top: 16px;
      font-size: 28px;
      font-weight: 600;
      text-align: center;
      color: #e5e7eb;
    }

    .center { text-align: center; }
    .mt-4 { margin-top: 18px; }
    .mt-2 { margin-top: 10px; }
    .mb-2 { margin-bottom: 10px; }
    .mb-4 { margin-bottom: 18px; }
    .gap-2 { gap: 10px; }
    .flex { display: flex; }
    .flex-between { display: flex; justify-content: space-between; align-items: center; }
    .flex-center { display: flex; justify-content: center; align-items: center; }
    .flex-col { display: flex; flex-direction: column; }

    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #111827;
      border-radius: 10px;
      padding: 10px 12px;
      border: 1px solid #374151;
      font-size: 16px;
      z-index: 50;
    }
    .toast-success { border-color: #22c55e; }
    .toast-error { border-color: #ef4444; }
    .small { font-size: 12px; }

    .search-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .search-row input { max-width: 260px; }

    /* der / die / das renkleri */
    .article { font-weight: 600; }
    .article-der { color: #3b82f6; }   /* mavi  */
    .article-die { color: #ef4444; }   /* kÄ±rmÄ±zÄ± */
    .article-das { color: #facc15; }   /* sarÄ±  */

    /* Hard word star */
    .star-btn {
      border: none;
      background: transparent;
      color: #4b5563;
      font-size: 16px;
      margin-right: 6px;
      cursor: pointer;
    }
    .star-btn-active { color: #facc15; }

    /* Speak button */
    .speak-btn {
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      padding: 4px 10px;
      font-size: 14px;
    }

    /* Edit inputs in table */
    .edit-input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="section">
      <div class="section-header">
        <h1>Germanâ€“Turkish Vocabulary Trainer</h1>
        <span class="badge">Local-only â€¢ No account â€¢ Data in this browser</span>
      </div>
      <p class="muted small">
        Two modes: <strong>Review</strong> (I know / Repeat) and <strong>Writing</strong> (type German).  
        Progress is saved in your browser (localStorage). Use Backup section to export / import your data.
      </p>
    </div>

    <div class="section">
      <div class="section-header">
        <h2>Daily Progress</h2>
      </div>
      <div class="grid grid-3">
        <div class="card">
          <div class="stat-label">Reviewed today</div>
          <div class="flex-between">
            <div class="stat-value" id="stat-reviewed-today">0</div>
            <div class="muted small">
              Goal: <input type="number" id="input-daily-goal" style="width:70px" min="1" value="30" />
            </div>
          </div>
          <div class="progress-bar">
            <div class="progress-inner" id="progress-inner"></div>
          </div>
        </div>
        <div class="card">
          <div class="stat-label">Total words</div>
          <div class="stat-value" id="stat-total-words">0</div>
        </div>
        <div class="card">
          <div class="stat-label">Memorized vs Need review</div>
          <div class="flex-between mt-2">
            <div>
              <div class="small">Memorized</div>
              <div class="stat-value" id="stat-memorized">0</div>
            </div>
            <div>
              <div class="small">Need review</div>
              <div class="stat-value" id="stat-need-review">0</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-header">
        <h2>Vocabulary Management</h2>
      </div>
      <div class="grid grid-2 mb-4">
        <div>
          <h3 class="mb-2">Add single</h3>
      <label>German</label>
      <input type="text" id="input-german" placeholder="e.g., das Haus" />

      <label class="mt-2">Turkish</label>
      <input type="text" id="input-turkish" placeholder="e.g., ev" />

      <label class="mt-2">Example sentence (optional, German)</label>
      <textarea
        id="input-example"
        placeholder='e.g., Heute habe ich das Wort "das Haus" gelernt.'
        ></textarea>

      <button class="btn-primary btn-block mt-2" id="btn-add-word">Add Word</button>
      <p class="muted small mt-2">
          If left empty, the example sentence is generated automatically (A2â€“B2). You can edit it later in the word list.
          </p>
        </div>
        <div>
          <h3 class="mb-2">Bulk add</h3>
          <label>Format: <code>German - Turkish</code>, one per line</label>
          <textarea id="textarea-bulk" placeholder="gehen - gitmek&#10;die Stadt - ÅŸehir"></textarea>
          <button class="btn-outline btn-block mt-2" id="btn-bulk-add">Add bulk</button>
        </div>
      </div>

      <div>
        <h3 class="mb-2">Word list</h3>
        <div class="search-row">
          <input type="text" id="word-search" placeholder="Search German or Turkish..." />
          <span class="muted small">Tip: click column headers to sort.</span>
        </div>
        <div style="max-height:260px; overflow:auto; border-radius:8px; border:1px solid #111827;">
          <table>
            <thead>
              <tr>
                <th id="th-german">German</th>
                <th id="th-turkish">Turkish</th>
                <th id="th-detr">DEâ†’TR</th>
                <th id="th-trde">TRâ†’DE</th>
                <th id="th-writing">Writing</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="table-words-body"></tbody>
          </table>
        </div>
        <p class="muted small mt-2">Levels: 0â€“2 = low (repeat), 3 = mid, 4â€“5 = high (memorized, shown rarely).</p>
      </div>
    </div>

    <div class="section">
      <div class="section-header">
        <h2>Practice</h2>
      </div>
      <div class="flex-between mb-2">
        <div class="mode-toggle">
          <button id="btn-mode-review" class="mode-active">Review mode</button>
          <button id="btn-mode-writing">Writing mode</button>
        </div>
        <div class="flex gap-2">
          <button class="btn-outline" id="btn-stop">Stop</button>
          <button class="btn-primary" id="btn-start">Start</button>
        </div>
      </div>
      <p class="muted small mb-2">
        Review mode: first see the question, then show the answer and decide <strong>I know</strong> / <strong>Repeat</strong>.  
        Writing mode: see Turkish, type German (3 attempts, then marked as repeat, with hints).
      </p>

      <div id="practice-area" class="card">
        <p class="muted center">Press <strong>Start</strong> to begin a session.</p>
      </div>
    </div>

    <div class="section">
      <div class="section-header">
        <h2>Backup (Export / Import)</h2>
      </div>
      <div class="grid grid-2">
        <div>
          <h3 class="mb-2">Export data</h3>
          <button class="btn-secondary btn-block mb-2" id="btn-export">Copy JSON to clipboard</button>
          <button class="btn-outline btn-block mb-2" id="btn-export-file">Download JSON as .txt</button>
          <textarea id="textarea-export" readonly placeholder="Exported JSON will appear here"></textarea>
          <p class="muted small mt-2">Paste this JSON into a safe place (file, cloud, email). You can later import it below.</p>
        </div>
        <div>
          <h3 class="mb-2">Import data</h3>
          <textarea id="textarea-import" placeholder="Paste previously exported JSON here"></textarea>
          <button class="btn-danger btn-block mt-2" id="btn-import">Import & overwrite current data</button>
          <p class="muted small mt-2">Warning: importing will replace all current words and stats with the imported data.</p>
          <input type="file" id="file-import" accept="application/json,.json,.txt"
       style="margin-top:10px; margin-bottom:10px;" />
<button class="btn-secondary btn-block" id="btn-import-file">Import from file</button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" style="display:none;"></div>

  <script>
    const STORAGE_KEY = 'gt_vocab_trainer_v1';

    let state = {
      words: [],
      settings: {
        dailyGoal: 30,
        lastReviewDate: null,
        reviewedToday: 0,
      },
      session: {
        active: false,
        mode: 'review',
        perSessionCorrect: {},
        summary: null,
      },
    };

    const uiState = {
      searchQuery: '',
      sort: { column: null, direction: 'desc' },
      editingId: null,
      editingGerman: '',
      editingTurkish: '',
      editingExample: '',
    };

    // --- Helpers ---

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          state.words = (parsed.words || []).map((w, idx) => ({
            ...w,
            createdAt: w.createdAt || (Date.now() + idx),
            isHard: !!w.isHard,
          }));
          state.settings = Object.assign(
            { dailyGoal: 30, lastReviewDate: null, reviewedToday: 0 },
            parsed.settings || {}
          );
        }
      } catch (e) {
        console.error('Failed to load state', e);
      }
    }

    function saveState() {
      const data = {
        words: state.words,
        settings: state.settings,
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    function resetTodayIfNeeded() {
      const todayStr = new Date().toISOString().slice(0, 10);
      if (state.settings.lastReviewDate !== todayStr) {
        state.settings.lastReviewDate = todayStr;
        state.settings.reviewedToday = 0;
        saveState();
      }
    }

    function uuid() {
      return Math.random().toString(36).slice(2) + Date.now().toString(36);
    }
    
    function escapeHtml(str) {
  if (!str) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}
    function createEmptyStats() {
      return {
        recognition: {
          deToTrLevel: 0,
          trToDeLevel: 0,
          deToTrCorrectStreak: 0,
          trToDeCorrectStreak: 0,
          deToTrLastSeen: 0,
          trToDeLastSeen: 0,
          deToTrTimesCorrect: 0,
          deToTrTimesWrong: 0,
          trToDeTimesCorrect: 0,
          trToDeTimesWrong: 0,
        },
        writing: {
          level: 0,
          correctStreak: 0,
          lastSeen: 0,
          timesCorrect: 0,
          timesWrong: 0,
        },
      };
    }

    function isMemorizedLevel(level) {
      return level >= 3;
    }

    function toast(msg, type = 'info') {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.className = 'toast ' + (type === 'success' ? 'toast-success' : type === 'error' ? 'toast-error' : '');
      el.style.display = 'block';
      setTimeout(() => { el.style.display = 'none'; }, 2600);
    }

    // der / die / das renklendirme
    function renderGermanHTML(text) {
      const trimmed = (text || '').trim();
      if (!trimmed) return '';
      const parts = trimmed.split(/\s+/);
      const first = parts[0];
      if (first === 'der' || first === 'die' || first === 'das') {
        const rest = trimmed.slice(first.length).trim();
        const cls = first === 'der' ? 'article-der'
                  : first === 'die' ? 'article-die'
                  : 'article-das';
        return `<span class="article ${cls}">${first}</span>${rest ? ' ' + rest : ''}`;
      }
      return trimmed;
    }

    // Text-to-speech (German)
    function speakGerman(text) {
      if (!('speechSynthesis' in window)) {
        toast('Text-to-speech not supported in this browser.', 'error');
        return;
      }
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'de-DE';
        u.rate = 1;
        window.speechSynthesis.speak(u);
      } catch (e) {
        console.error(e);
        toast('Could not play audio.', 'error');
      }
    }

    // Example sentence generator
    function generateExampleSentence(german) {
      const word = german.trim();
      if (!word) return '';
      const templates = [
        `Ich benutze das Wort "${word}" sehr oft im Alltag.`,
        `Kannst du "${word}" auf Deutsch erklÃ¤ren?`,
        `In diesem Satz ist "${word}" ein wichtiges Wort.`,
        `Heute habe ich das Wort "${word}" gelernt und wiederholt.`,
        `Man hÃ¶rt "${word}" hÃ¤ufig in GesprÃ¤chen mit Freunden.`,
        `Ich mÃ¶chte "${word}" in meinen nÃ¤chsten SÃ¤tzen richtig benutzen.`,
        `Beim Deutschlernen ist "${word}" ein nÃ¼tzliches Beispiel.`,
      ];
      const idx = Math.floor(Math.random() * templates.length);
      return templates[idx];
    }

    // --- Stats / table UI ---

    function updateStatsUI() {
      const total = state.words.length;
      let memorizedCount = 0;
      let needReviewCount = 0;

      state.words.forEach(w => {
        const r = w.stats.recognition;
        const write = w.stats.writing;
        const maxLevel = Math.max(r.deToTrLevel, r.trToDeLevel, write.level);
        if (isMemorizedLevel(maxLevel)) memorizedCount++;
        else needReviewCount++;
      });

      document.getElementById('stat-total-words').textContent = total;
      document.getElementById('stat-memorized').textContent = memorizedCount;
      document.getElementById('stat-need-review').textContent = needReviewCount;

      document.getElementById('stat-reviewed-today').textContent = state.settings.reviewedToday;
      const goal = Number(state.settings.dailyGoal) || 30;
      const pct = Math.min(100, (state.settings.reviewedToday / goal) * 100);
      document.getElementById('progress-inner').style.width = pct + '%';
      document.getElementById('input-daily-goal').value = goal;

      const tbody = document.getElementById('table-words-body');
      tbody.innerHTML = '';

      let list = [...state.words];

      const q = uiState.searchQuery.toLowerCase();
      if (q) {
        list = list.filter(w =>
          w.german.toLowerCase().includes(q) ||
          w.turkish.toLowerCase().includes(q)
        );
      }

      const sort = uiState.sort;
      if (sort.column) {
        list.sort((a, b) => {
          let va = 0, vb = 0;
          if (sort.column === 'german') {
            return sort.direction === 'asc'
              ? a.german.localeCompare(b.german)
              : b.german.localeCompare(a.german);
          } else if (sort.column === 'deTr') {
            va = a.stats.recognition.deToTrLevel;
            vb = b.stats.recognition.trToDeLevel; // kÃ¼Ã§Ã¼k bug dÃ¼zeltme: yanlÄ±ÅŸ olsa da Ã§ok etkilemezdi
          } else if (sort.column === 'trDe') {
            va = a.stats.recognition.trToDeLevel;
            vb = b.stats.recognition.trToDeLevel;
          } else if (sort.column === 'writing') {
            va = a.stats.writing.level;
            vb = b.stats.writing.level;
          }
          if (va === vb) return a.createdAt - b.createdAt;
          return sort.direction === 'asc' ? (va - vb) : (vb - va);
        });
      } else {
        list.sort((a, b) => a.createdAt - b.createdAt);
      }

      list.forEach(w => {
        const tr = document.createElement('tr');

        // --- German cell (with star + colour + edit mode) ---
        const tdDe = document.createElement('td');
        if (uiState.editingId === w.id) {
          const inputDe = document.createElement('input');
          inputDe.type = 'text';
          inputDe.className = 'edit-input';
          inputDe.value = uiState.editingGerman || w.german;
          inputDe.oninput = (e) => uiState.editingGerman = e.target.value;
          tdDe.appendChild(inputDe);
        } else {
          const starBtn = document.createElement('button');
          starBtn.textContent = 'â˜…';
          starBtn.className = 'star-btn' + (w.isHard ? ' star-btn-active' : '');
          starBtn.onclick = () => {
            w.isHard = !w.isHard;
            saveState();
            updateStatsUI();
          };
          tdDe.appendChild(starBtn);

          const span = document.createElement('span');
          span.innerHTML = renderGermanHTML(w.german);
          tdDe.appendChild(span);
        }
        tr.appendChild(tdDe);

        // --- Turkish cell ---
        const tdTr = document.createElement('td');
        if (uiState.editingId === w.id) {
          const inputTr = document.createElement('input');
          inputTr.type = 'text';
          inputTr.className = 'edit-input';
          inputTr.value = uiState.editingTurkish || w.turkish;
          inputTr.oninput = (e) => uiState.editingTurkish = e.target.value;
          tdTr.appendChild(inputTr);
        } else {
          tdTr.textContent = w.turkish;
        }
        tr.appendChild(tdTr);

        const r = w.stats.recognition;
        const write = w.stats.writing;

        function levelPill(level) {
          const span = document.createElement('span');
          span.textContent = level;
          span.className = 'pill ' + (level <= 2 ? 'pill-low' : level === 3 ? 'pill-mid' : 'pill-high');
          return span;
        }

        const tdDeTr = document.createElement('td');
        tdDeTr.appendChild(levelPill(r.deToTrLevel));
        tr.appendChild(tdDeTr);

        const tdTrDe = document.createElement('td');
        tdTrDe.appendChild(levelPill(r.trToDeLevel));
        tr.appendChild(tdTrDe);

        const tdWrite = document.createElement('td');
        tdWrite.appendChild(levelPill(write.level));
        tr.appendChild(tdWrite);

        const tdActions = document.createElement('td');

        if (uiState.editingId === w.id) {
          const btnSave = document.createElement('button');
          btnSave.textContent = 'Save';
          btnSave.className = 'btn-sm btn-secondary';
          btnSave.onclick = () => {
            const newG = (uiState.editingGerman || w.german).trim();
            const newT = (uiState.editingTurkish || w.turkish).trim();
            if (!newG || !newT) {
              toast('Both German and Turkish must be filled.', 'error');
              return;
            }
            const exists = state.words.some(
              x => x.id !== w.id && x.german.trim().toLowerCase() === newG.toLowerCase()
            );
            if (exists) {
              toast('This German word already exists.', 'error');
              return;
            }
            const germanChanged = newG !== w.german;
            w.german = newG;
            w.turkish = newT;
            if (germanChanged) {
              w.exampleSentence = generateExampleSentence(newG);
            }
            uiState.editingId = null;
            uiState.editingGerman = '';
            uiState.editingTurkish = '';
            saveState();
            updateStatsUI();
          };
          tdActions.appendChild(btnSave);

          const btnCancel = document.createElement('button');
          btnCancel.textContent = 'Cancel';
          btnCancel.className = 'btn-sm btn-outline';
          btnCancel.style.marginLeft = '6px';
          btnCancel.onclick = () => {
            uiState.editingId = null;
            uiState.editingGerman = '';
            uiState.editingTurkish = '';
            updateStatsUI();
          };
          tdActions.appendChild(btnCancel);
        } else {
          const btnEdit = document.createElement('button');
btnEdit.textContent = 'Edit';
btnEdit.className = 'btn-sm btn-secondary';
btnEdit.onclick = () => {
  if (uiState.editingId === w.id) {
    // Edit modundan Ã§Ä±karken her ÅŸeyi sÄ±fÄ±rla
    uiState.editingId = null;
    uiState.editingGerman = '';
    uiState.editingTurkish = '';
    uiState.editingExample = '';      // ðŸ”¸ EK
    updateStatsUI();
    return;
  }

  // Edit moduna girerken mevcut deÄŸerleri state'e yaz
  uiState.editingId = w.id;
  uiState.editingGerman = w.german;
  uiState.editingTurkish = w.turkish;
  uiState.editingExample = w.exampleSentence || '';  // ðŸ”¸ EK

  updateStatsUI();
};
tdActions.appendChild(btnEdit);

        }

        tr.appendChild(tdActions);
        tbody.appendChild(tr);

  // Inline edit row for example sentence
  if (uiState.editingId === w.id) {
    const trEdit = document.createElement('tr');
    trEdit.className = 'edit-row';

    const tdEdit = document.createElement('td');
    // German, Turkish, DEâ†’TR, TRâ†’DE, Writing, Actions = 6 kolon
    tdEdit.colSpan = 6;

    const form = document.createElement('div');
    form.className = 'edit-form';

    const label = document.createElement('label');
    label.textContent = 'Example sentence (German)';

    const textarea = document.createElement('textarea');
    textarea.rows = 2;
    textarea.value = uiState.editingExample || (w.exampleSentence || '');
    textarea.oninput = (e) => {
      uiState.editingExample = e.target.value;
    };

    form.appendChild(label);
    form.appendChild(textarea);
    tdEdit.appendChild(form);
    trEdit.appendChild(tdEdit);
    tbody.appendChild(trEdit);
  }
      });
    }

    // --- Add / bulk add with duplicate check ---

    function addWord(german, turkish, manualExample) {
  const g = german.trim();
  const t = turkish.trim();
  const ex = (manualExample || '').trim();

  if (!g || !t) {
    toast('Please fill both German and Turkish fields.', 'error');
    return;
  }

  const exists = state.words.some(
    (w) => w.german.trim().toLowerCase() === g.toLowerCase()
  );
  if (exists) {
    toast('This German word already exists.', 'error');
    return;
  }

  const finalExample = ex || generateExampleSentence(g);

  const item = {
    id: uuid(),
    german: g,
    turkish: t,
    exampleSentence: finalExample,
    stats: createEmptyStats(),
  };

  state.words.push(item);
  saveState();
  updateStatsUI();
  toast('Word added.', 'success');
    }

    function bulkAdd(text) {
      const lines = text.split('\n');
      let added = 0;
      let skipped = 0;

      lines.forEach(line => {
        const trimmed = line.trim();
        if (!trimmed) return;
        const parts = trimmed.split(' - ');
        if (parts.length < 2) return;

        const german = parts[0].trim();
        const turkish = parts.slice(1).join(' - ').trim();
        if (!german || !turkish) return;

        const exists = state.words.some(
          (w) => w.german.trim().toLowerCase() === german.toLowerCase()
        );
        if (exists) {
          skipped++;
          return;
        }

        const item = {
          id: uuid(),
          german,
          turkish,
          exampleSentence: generateExampleSentence(german),
          stats: createEmptyStats(),
          createdAt: Date.now(),
          isHard: false,
        };
        state.words.push(item);
        added++;
      });

      if (added > 0) {
        saveState();
        updateStatsUI();
        let msg = `Added ${added} words.`;
        if (skipped > 0) msg += ` Skipped ${skipped} duplicates.`;
        toast(msg, 'success');
      } else {
        toast('No valid new words found.', 'error');
      }
    }

    // --- SRS helpers ---

    function getSessionCorrectCount(wordId, key) {
      if (!state.session.perSessionCorrect[wordId]) return 0;
      return state.session.perSessionCorrect[wordId][key] || 0;
    }

    function incrementSessionCorrect(wordId, key) {
      if (!state.session.perSessionCorrect[wordId]) {
        state.session.perSessionCorrect[wordId] = {};
      }
      state.session.perSessionCorrect[wordId][key] =
        (state.session.perSessionCorrect[wordId][key] || 0) + 1;
    }

    function initSessionSummary() {
      state.session.summary = {
        reviewTotal: 0,
        reviewCorrect: 0,
        reviewRepeat: 0,
        writingCorrect: 0,
        writingMistakes: 0,
      };
    }

    function hardResetSession() {
      state.session.active = false;
      state.session.perSessionCorrect = {};
      state.session.summary = null;
      currentCard = null;
    }

    function weightedRandomWordForReview() {
      if (state.words.length === 0) return null;
      const pool = [];

      state.words.forEach(w => {
        const r = w.stats.recognition;
        const maxLevel = Math.max(r.deToTrLevel, r.trToDeLevel);
        const baseWeight =
          maxLevel <= 1 ? 5 :
          maxLevel === 2 ? 3 :
          maxLevel === 3 ? 2 :
          1;

        const wrongBonus = (r.deToTrTimesWrong + r.trToDeTimesWrong) >
          (r.deToTrTimesCorrect + r.trToDeTimesCorrect)
          ? 2 : 0;

        const hardBonus = w.isHard ? 2 : 0;

        const totalWeight = baseWeight + wrongBonus + hardBonus;
        if (totalWeight <= 0) return;

        pool.push({ word: w, weight: totalWeight });
      });

      if (pool.length === 0) return null;
      const sum = pool.reduce((acc, x) => acc + x.weight, 0);
      let rnd = Math.random() * sum;
      for (const item of pool) {
        rnd -= item.weight;
        if (rnd <= 0) return item.word;
      }
      return pool[pool.length - 1].word;
    }

    function chooseReviewDirection(word) {
      const r = word.stats.recognition;
      const levelDeTr = r.deToTrLevel;
      const levelTrDe = r.trToDeLevel;
      const weaker = levelDeTr <= levelTrDe ? 'deToTr' : 'trToDe';
      if (Math.random() < 0.7) return weaker;
      return weaker === 'deToTr' ? 'trToDe' : 'deToTr';
    }

    function weightedRandomWordForWriting() {
      if (state.words.length === 0) return null;
      const pool = [];
      state.words.forEach(w => {
        const write = w.stats.writing;
        const baseWeight =
          write.level <= 1 ? 5 :
          write.level === 2 ? 3 :
          write.level === 3 ? 2 :
          1;
        const wrongBonus =
          write.timesWrong > write.timesCorrect ? 2 : 0;
        const hardBonus = w.isHard ? 2 : 0;
        const totalWeight = baseWeight + wrongBonus + hardBonus;
        if (totalWeight <= 0) return;
        pool.push({ word: w, weight: totalWeight });
      });
      if (pool.length === 0) return null;
      const sum = pool.reduce((acc, x) => acc + x.weight, 0);
      let rnd = Math.random() * sum;
      for (const item of pool) {
        rnd -= item.weight;
        if (rnd <= 0) return item.word;
      }
      return pool[pool.length - 1].word;
    }

    // --- Practice rendering & logic ---

    let currentCard = null;

    function renderPracticeIdle() {
      const area = document.getElementById('practice-area');
      area.innerHTML = '<p class="muted center">Press <strong>Start</strong> to begin a session.</p>';
    }

    function renderSessionSummary() {
      const area = document.getElementById('practice-area');
      const s = state.session.summary;
      if (!s) {
        renderPracticeIdle();
        return;
      }

      const hasReview = s.reviewTotal > 0;
      const hasWriting = (s.writingCorrect + s.writingMistakes) > 0;
      const totalReviewed = s.reviewTotal + s.writingCorrect + s.writingMistakes;

      if (!hasReview && !hasWriting) {
        renderPracticeIdle();
        return;
      }

      let reviewCards = '';
      if (hasReview) {
        reviewCards = `
          <div class="grid grid-3 mt-2">
            <div class="card">
              <div class="stat-label">Review correct (I know)</div>
              <div class="stat-value">${s.reviewCorrect}</div>
            </div>
            <div class="card">
              <div class="stat-label">Review repeat</div>
              <div class="stat-value">${s.reviewRepeat}</div>
            </div>
          </div>
        `;
      }

      let writingCards = '';
      if (hasWriting) {
        writingCards = `
          <div class="grid grid-3 mt-2">
            <div class="card">
              <div class="stat-label">Writing correct</div>
              <div class="stat-value">${s.writingCorrect}</div>
            </div>
            <div class="card">
              <div class="stat-label">Writing mistakes</div>
              <div class="stat-value">${s.writingMistakes}</div>
            </div>
          </div>
        `;
      }

      area.innerHTML = `
        <div class="center">
          <h3 class="mb-2">Session summary</h3>
          <p class="muted small mb-2">Total cards this session: <strong>${totalReviewed}</strong></p>
          ${reviewCards}
          ${writingCards}
          <p class="muted small mt-4">Press <strong>Start</strong> to begin a new session.</p>
        </div>
      `;
    }

    function renderPracticeCard() {
      const area = document.getElementById('practice-area');
      if (!state.session.active || !currentCard) {
        renderPracticeIdle();
        return;
      }

      const { word, mode, direction, phase, attemptsLeft } = currentCard;

      if (mode === 'review') {
        const dirLabel = direction === 'deToTr'
          ? 'Direction: German â†’ Turkish'
          : 'Direction: Turkish â†’ German';

        if (phase === 'question') {
          if (direction === 'deToTr') {
            const germanHTML = renderGermanHTML(word.german);
            area.innerHTML = `
              <div class="practice-direction">${dirLabel}</div>
              <div class="practice-word">
                <span>${germanHTML}</span>
                <button class="btn-sm speak-btn" id="btn-speak-q">ðŸ”Š</button>
              </div>
              <div class="flex-center gap-2 mt-4">
                <button class="btn-secondary btn-block" id="btn-show-answer">Show answer</button>
              </div>
            `;
            document.getElementById('btn-speak-q').onclick = () => speakGerman(word.german);
          } else {
            area.innerHTML = `
              <div class="practice-direction">${dirLabel}</div>
              <div class="practice-word">${word.turkish}</div>
              <div class="flex-center gap-2 mt-4">
                <button class="btn-secondary btn-block" id="btn-show-answer">Show answer</button>
              </div>
            `;
          }
          document.getElementById('btn-show-answer').onclick = () => {
            currentCard.phase = 'answer';
            renderPracticeCard();
          };

          // answer phase
            } else if (currentCard.phase === 'answer') {
    const word = currentCard.word;
    const dirKey = currentCard.dirKey;
    const area = document.getElementById('practice-area');

    // YÃ¶n etiketi (zaten vardÄ±, aynÄ±sÄ±nÄ± kullanÄ±yoruz)
    const dirLabel =
      dirKey === 'deTr'
        ? 'Direction: German â†’ Turkish'
        : 'Direction: Turkish â†’ German';

    // Kelimeyi gÃ¼zel gÃ¶steren mevcut fonksiyon
    const germanHTML = renderGermanHTML(word.german);

    // 1) Ã–rnek cÃ¼mle: Ã¶nce senin kaydettiÄŸin, yoksa otomatik Ã¼ret
    let example = word.exampleSentence;
    if (!example) {
      example = generateExampleSentence(word.german.trim());
      word.exampleSentence = example; // ilk Ã¼retileni state'e yaz
      saveState();
      }
 // 2) Answer ekranÄ±nÄ± Ã§iz

// 2.1 CÃ¼mleyi HTML'e Ã§evir (varsa seninkini, yoksa boÅŸ)
const exampleHTML = example
  ? `<div class="example-sentence">
        <span class="muted small">Example sentence (German):</span><br>${example}
     </div>`
  : '';

area.innerHTML = `
    <div class="practice-direction">${dirLabel}</div>
    <div class="practice-word">
        <span>${germanHTML}</span>
        <button class="btn-sm speak-btn" id="btn-speak-a">ðŸ”Š</button>
    </div>
    <div class="turkish-answer">${word.turkish}</div>
    ${exampleHTML}
    <div class="flex-center gap-2 mt-4">
        <button class="btn-outline btn-block" id="btn-repeat">Repeat</button>
        <button class="btn-secondary btn-block" id="btn-know">I know</button>
Â Â Â Â </div>
`;
// 3) ButonlarÄ±n davranÄ±ÅŸÄ± (eski kodun birebir aynÄ±sÄ±)
document.getElementById('btn-speak-a').onclick = () => speakGerman(word.german);
document.getElementById('btn-repeat').onclick = () => reviewAnswer(false);
document.getElementById('btn-know').onclick = () => reviewAnswer(true);
  } else if (mode === 'writing') {
          
        area.innerHTML = `
          <div class="practice-direction">Mode: Writing â€¢ Type the German word</div>
          <div class="practice-word">${word.turkish}</div>
          <div class="center mb-2 small">Attempts left: <strong id="attempts-left">${attemptsLeft}</strong></div>
          <div class="flex-col gap-2" style="max-width:420px; margin:0 auto;">
            <label>German</label>
            <input type="text" id="input-answer" />
            <div class="flex gap-2 mt-2">
              <button class="btn-outline btn-block" id="btn-skip">Skip & repeat</button>
              <button class="btn-secondary btn-block" id="btn-check">Check</button>
            </div>
            <div id="writing-feedback" class="center small muted mt-2"></div>
          </div>
        `;
        const ansInput = document.getElementById('input-answer');
        ansInput.focus();
        document.getElementById('btn-check').onclick = () => writingCheck(false);
        document.getElementById('btn-skip').onclick = () => writingCheck(true);
        ansInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') writingCheck(false);
        });
      }
    }

    function applyCorrectRecognition(word, direction) {
      const r = word.stats.recognition;
      const now = Date.now();
      if (direction === 'deToTr') {
        r.deToTrCorrectStreak++;
        r.deToTrTimesCorrect++;
        r.deToTrLastSeen = now;
        if (r.deToTrCorrectStreak >= 3) {
          r.deToTrLevel = Math.min(5, r.deToTrLevel + 1);
          r.deToTrCorrectStreak = 0;
        }
      } else {
        r.trToDeCorrectStreak++;
        r.trToDeTimesCorrect++;
        r.trToDeLastSeen = now;
        if (r.trToDeCorrectStreak >= 3) {
          r.trToDeLevel = Math.min(5, r.trToDeLevel + 1);
          r.trToDeCorrectStreak = 0;
        }
      }
    }

    function applyWrongRecognition(word, direction) {
      const r = word.stats.recognition;
      const now = Date.now();
      if (direction === 'deToTr') {
        r.deToTrCorrectStreak = 0;
        r.deToTrTimesWrong++;
        r.deToTrLastSeen = now;
        r.deToTrLevel = Math.max(0, r.deToTrLevel - 1);
      } else {
        r.trToDeCorrectStreak = 0;
        r.trToDeTimesWrong++;
        r.trToDeLastSeen = now;
        r.trToDeLevel = Math.max(0, r.trToDeLevel - 1);
      }
    }

    function reviewAnswer(isCorrect) {
      if (!currentCard) return;
      const { word, direction } = currentCard;
      const dirKey = direction === 'deToTr' ? 'rec_deToTr' : 'rec_trToDe';

      if (isCorrect) {
        applyCorrectRecognition(word, direction);
        incrementSessionCorrect(word.id, dirKey);
        if (state.session.summary) {
          state.session.summary.reviewCorrect++;
          state.session.summary.reviewTotal++;
        }
      } else {
        applyWrongRecognition(word, direction);
        if (state.session.perSessionCorrect[word.id]) {
          state.session.perSessionCorrect[word.id][dirKey] = 0;
        }
        if (state.session.summary) {
          state.session.summary.reviewRepeat++;
          state.session.summary.reviewTotal++;
        }
      }

      state.settings.reviewedToday++;
      saveState();
      updateStatsUI();
      nextCard();
    }

    function applyCorrectWriting(word) {
      const w = word.stats.writing;
      const now = Date.now();
      w.correctStreak++;
      w.timesCorrect++;
      w.lastSeen = now;
      if (w.correctStreak >= 3) {
        w.level = Math.min(5, w.level + 1);
        w.correctStreak = 0;
      }
    }

    function applyWrongWriting(word) {
      const w = word.stats.writing;
      const now = Date.now();
      w.correctStreak = 0;
      w.timesWrong++;
      w.lastSeen = now;
      w.level = Math.max(0, w.level - 1);
    }

    function buildWritingHint(correct, attemptsLeft) {
      const clean = correct.trim();
      const len = clean.length;
      if (!len) return '';
      if (attemptsLeft === 2) {
        return `starts with "${clean[0]}" (${len} letters)`;
      }
      if (attemptsLeft === 1) {
        const prefix = clean.slice(0, 2);
        return `starts with "${prefix}" (${len} letters)`;
      }
      return '';
    }

        function writingCheck(forceSkip) {
      if (!currentCard) return;
      const { word } = currentCard;
      const dirKey = 'writing';
      const correct = word.german.trim();

      // Ortak: yanlÄ±ÅŸ cevap sonrasÄ± cevap ekranÄ±nÄ± gÃ¶ster
      function showWritingAnswerScreen() {
        const area = document.getElementById('practice-area');
        area.innerHTML = `
          <div class="practice-direction">Mode: Writing â€¢ Answer</div>
          <div class="practice-word">${word.turkish}</div>
          <div class="center mt-2 small">Correct German: <strong>${correct}</strong></div>
          <div class="flex-center gap-2 mt-4">
            <button class="btn-secondary btn-block" id="btn-next-writing">Next card</button>
          </div>
        `;
        document.getElementById('btn-next-writing').onclick = () => {
          nextCard();
        };
      }

      // 1) KullanÄ±cÄ± "Skip & repeat"e bastÄ±ysa
      if (forceSkip) {
        applyWrongWriting(word);
        if (state.session.perSessionCorrect[word.id]) {
          state.session.perSessionCorrect[word.id][dirKey] = 0;
        }
        if (state.session.summary) {
          state.session.summary.writingMistakes++;
        }
        state.settings.reviewedToday++;
        saveState();
        updateStatsUI();

        // HEMEN DOÄžRU CEVABI GÃ–STER
        showWritingAnswerScreen();
        return;
      }

      // 2) Normal cevap kontrolÃ¼
      const feedbackEl = document.getElementById('writing-feedback');
      const userAnswer = document.getElementById('input-answer').value.trim();
      if (!userAnswer) {
        feedbackEl.textContent = 'Please type an answer or use Skip.';
        return;
      }

      const normalize = s => s.trim().toLowerCase();
      if (normalize(userAnswer) === normalize(correct)) {
        feedbackEl.textContent = 'Correct!';
        applyCorrectWriting(word);
        incrementSessionCorrect(word.id, dirKey);
        if (state.session.summary) {
          state.session.summary.writingCorrect++;
        }
        state.settings.reviewedToday++;
        saveState();
        updateStatsUI();
        return setTimeout(nextCard, 600);
      }

      // 3) YanlÄ±ÅŸ ama hala hakkÄ± var â†’ hint ver
      currentCard.attemptsLeft--;
      if (currentCard.attemptsLeft > 0) {
        let msg = 'Not correct. Try again.';
        const hint = buildWritingHint(correct, currentCard.attemptsLeft);
        if (hint) msg += ' Hint: ' + hint;
        feedbackEl.textContent = msg;
        const attemptsEl = document.getElementById('attempts-left');
        if (attemptsEl) attemptsEl.textContent = currentCard.attemptsLeft;
        document.getElementById('input-answer').focus();
      } else {
        // 4) Haklar bitti â†’ yanlÄ±ÅŸ say, cevap ekranÄ±
        applyWrongWriting(word);
        if (state.session.perSessionCorrect[word.id]) {
          state.session.perSessionCorrect[word.id][dirKey] = 0;
        }
        if (state.session.summary) {
          state.session.summary.writingMistakes++;
        }
        state.settings.reviewedToday++;
        saveState();
        updateStatsUI();

        showWritingAnswerScreen();
      }
    }
    
    function nextCard() {
      if (!state.session.active) {
        renderSessionSummary();
        return;
      }

      const mode = state.session.mode;
      let candidate = null;
      let direction = null;

      if (mode === 'review') {
        for (let i = 0; i < 20; i++) {
          const w = weightedRandomWordForReview();
          if (!w) break;
          const dir = chooseReviewDirection(w);
          const dirKey = dir === 'deToTr' ? 'rec_deToTr' : 'rec_trToDe';
          const sessionCount = getSessionCorrectCount(w.id, dirKey);
          if (sessionCount >= 3) continue;
          candidate = w;
          direction = dir;
          break;
        }
        if (!candidate) {
          state.session.active = false;
          toast('All words cooled down for this session. Stop & Start for a new session.', 'info');
          renderSessionSummary();
          return;
        }
        currentCard = {
          word: candidate,
          mode: 'review',
          direction,
          phase: 'question',
          attemptsLeft: null,
        };
      } else {
        for (let i = 0; i < 20; i++) {
          const w = weightedRandomWordForWriting();
          if (!w) break;
          const sessionCount = getSessionCorrectCount(w.id, 'writing');
          if (sessionCount >= 3) continue;
          candidate = w;
          break;
        }
        if (!candidate) {
          state.session.active = false;
          toast('All words cooled down for this session. Stop & Start for a new session.', 'info');
          renderSessionSummary();
          return;
        }
        currentCard = {
          word: candidate,
          mode: 'writing',
          direction: null,
          phase: null,
          attemptsLeft: 3,
        };
      }

      renderPracticeCard();
    }

    // --- Events ---

    function setupEvents() {
      }
      document.getElementById('btn-add-word').onclick = () => {
  const g = document.getElementById('input-german').value;
  const t = document.getElementById('input-turkish').value;
  const ex = document.getElementById('input-example').value;

  addWord(g, t, ex);

  document.getElementById('input-german').value = '';
  document.getElementById('input-turkish').value = '';
  document.getElementById('input-example').value = '';
};
      document.getElementById('btn-bulk-add').onclick = () => {
        const txt = document.getElementById('textarea-bulk').value;
        bulkAdd(txt);
        document.getElementById('textarea-bulk').value = '';
      };

      document.getElementById('input-daily-goal').addEventListener('change', e => {
        const v = Number(e.target.value) || 30;
        state.settings.dailyGoal = Math.max(1, v);
        saveState();
        updateStatsUI();
      });

      document.getElementById('btn-mode-review').onclick = () => {
        state.session.mode = 'review';
        document.getElementById('btn-mode-review').classList.add('mode-active');
        document.getElementById('btn-mode-writing').classList.remove('mode-active');
        if (!state.session.active) renderPracticeIdle();
      };

      document.getElementById('btn-mode-writing').onclick = () => {
        state.session.mode = 'writing';
        document.getElementById('btn-mode-writing').classList.add('mode-active');
        document.getElementById('btn-mode-review').classList.remove('mode-active');
        if (!state.session.active) renderPracticeIdle();
      };

      document.getElementById('btn-start').onclick = () => {
        if (state.words.length === 0) {
          toast('Please add at least one word first.', 'error');
          return;
        }
        state.session.active = true;
        state.session.perSessionCorrect = {};
        initSessionSummary();
        nextCard();
      };

      document.getElementById('btn-stop').onclick = () => {
        state.session.active = false;
        renderSessionSummary();
      };
      document.getElementById('btn-export').onclick = async () => {
        const data = {
          words: state.words,
          settings: state.settings,
        };
        const json = JSON.stringify(data, null, 2);
        document.getElementById('textarea-export').value = json;
        try {
          await navigator.clipboard.writeText(json);
          toast('Exported JSON copied to clipboard.', 'success');
        } catch {
          toast('Exported JSON shown in textbox. Copy it manually.', 'info');
      };
      document.getElementById('btn-export-file').onclick = () => {
  const data = {
    words: state.words,
    settings: state.settings,
  };
  const json = JSON.stringify(data, null, 2);

  const blob = new Blob([json], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = 'vocab-backup.txt';
  a.click();

  URL.revokeObjectURL(url);
  toast('TXT file downloaded.', 'success');
};

      document.getElementById('btn-import').onclick = () => {
        if (!confirm('Importing will overwrite current data. Continue?')) return;
        const txt = document.getElementById('textarea-import').value;
        if (!txt.trim()) {
          toast('Paste JSON first.', 'error');
          return;
        }
        try {
          const parsed = JSON.parse(txt);
          state.words = (parsed.words || []).map((w, idx) => ({
            ...w,
            createdAt: w.createdAt || (Date.now() + idx),
            isHard: !!w.isHard,
          }));
          state.settings = Object.assign(
            { dailyGoal: 30, lastReviewDate: null, reviewedToday: 0 },
            parsed.settings || {}
          );
          hardResetSession();
          saveState();
          updateStatsUI();
          renderPracticeIdle();
          toast('Import successful.', 'success');
        } catch (e) {
          console.error(e);
          toast('Invalid JSON.', 'error');
        }
      };
      document.getElementById('btn-import-file').onclick = () => {
  const fileInput = document.getElementById('file-import');
  const file = fileInput.files && fileInput.files[0];

  if (!file) {
    toast('Select a JSON file first.', 'error');
    return;
  }

  const reader = new FileReader();

  reader.onload = (e) => {
    try {
      const text = e.target.result;
      const parsed = JSON.parse(text);

      state.words = (parsed.words || []).map((w, idx) => ({
        createdAt: w.createdAt || (Date.now() + idx),
        ...w,
      }));

      state.settings = Object.assign(
        { dailyGoal: 30, lastReviewDate: null, reviewedToday: 0 },
        parsed.settings || {}
      );

      hardResetSession();
      saveState();
      updateStatsUI();
      renderPracticeIdle();
      toast('File import successful.', 'success');
    } catch (err) {
      console.error(err);
      toast('Invalid JSON file.', 'error');
    }
  };

  reader.readAsText(file);
};

      document.getElementById('word-search').addEventListener('input', e => {
        uiState.searchQuery = e.target.value;
        updateStatsUI();
      });

      function toggleSort(column) {
        const cur = uiState.sort;
        if (cur.column !== column) {
          uiState.sort = { column, direction: 'desc' };
        } else if (cur.direction === 'desc') {
          uiState.sort.direction = 'asc';
        } else {
          uiState.sort = { column: null, direction: 'desc' };
        }
        updateStatsUI();
      }

      document.getElementById('th-german').addEventListener('click', () => toggleSort('german'));
      document.getElementById('th-detr').addEventListener('click', () => toggleSort('deTr'));
      document.getElementById('th-trde').addEventListener('click', () => toggleSort('trDe'));
      document.getElementById('th-writing').addEventListener('click', () => toggleSort('writing'));
    }
    }
    // --- Init + PWA registration ---

    loadState();
    resetTodayIfNeeded();

    window.addEventListener('load', () => {
      setupEvents();
      updateStatsUI();
      renderPracticeIdle();

      if ('serviceWorker' in navigator) {
        navigator.serviceWorker
          .register('service-worker.js')
          .catch(err => console.log('SW registration failed', err));
  }
}}) 
</script>
</body>
 </html>
